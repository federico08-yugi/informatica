<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>Test di Reazione - Trova il Colore Giusto</title>
  <style>
    .color-box {
      width: 150px;
      height: 150px;
      margin: 10px;
      cursor: pointer;
    }
    .image-container {
      display: flex;
      flex-wrap: wrap;
      max-width: 650px;
    }
    #reaction-chart {
      max-width: 600px;
      margin: 20px auto;
    }
  </style>
  <!-- Aggiungi Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h2>Test di reazione: clicca sul colore corretto</h2>
  <div class="image-container" id="colors"></div>
  <p id="status"></p>
  <p id="correct-color"></p>
  <p id="result"></p>

  <canvas id="reaction-chart"></canvas>

  <script>
    const totalRounds = 50; // Fissiamo a 50 round
    let reactionTimes1 = [];  // Dati del primo ciclo
    let reactionTimes2 = [];  // Dati del secondo ciclo
    let currentRound = 0;
    let startTime = 0;
    let colors = [];
    let correctColor = "";
    let cycle = 1;  // Contatore dei cicli (1 per il primo ciclo, 2 per il secondo ciclo)

    // Funzione per generare colori casuali
    function getRandomColor() {
      const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16);
      return randomColor;
    }

    // Funzione per calcolare la media
    function calculateMean(arr) {
      return arr.reduce((a, b) => a + b, 0) / arr.length;
    }

    // Funzione per calcolare la varianza
    function calculateVariance(arr, mean) {
      return arr.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / arr.length;
    }

    // Funzione per calcolare la deviazione standard
    function calculateStandardDeviation(variance) {
      return Math.sqrt(variance);
    }

    // Funzione per iniziare un round
    function startRound() {
      if (currentRound >= totalRounds) {
        if (cycle === 1) {
          cycle = 2;  // Passiamo al secondo ciclo
          currentRound = 0;
          setTimeout(startRound, 500);  // Pausa prima di cominciare il secondo ciclo
        } else {
          return showResults();
        }
      }

      // Crea i colori per il round corrente
      colors = [];
      for (let i = 0; i < 4; i++) {
        colors.push(getRandomColor());
      }

      // Seleziona un colore corretto casualmente
      const correctIndex = Math.floor(Math.random() * 4);
      correctColor = colors[correctIndex];

      // Mostra il colore corretto prima del round
      document.getElementById("correct-color").style.backgroundColor = correctColor;
      document.getElementById("correct-color").textContent = `Colore corretto: Clicca su questo colore`;

      const container = document.getElementById("colors");
      container.innerHTML = '';
      colors.forEach((color, index) => {
        const box = document.createElement("div");
        box.style.backgroundColor = color;
        box.classList.add("color-box");
        box.onclick = () => handleClick(index === correctIndex, color);
        container.appendChild(box);
      });

      // Avvia il timer per il round
      startTime = performance.now();
      document.getElementById("status").textContent = `Round ${currentRound + 1} di ${totalRounds}`;
    }

    // Funzione per gestire il clic dell'utente
    function handleClick(isCorrect, color) {
      if (isCorrect) {
        const endTime = performance.now();
        const reactionTime = endTime - startTime;
        if (cycle === 1) {
          reactionTimes1.push(reactionTime);
        } else {
          reactionTimes2.push(reactionTime);
        }
        currentRound++;
        setTimeout(startRound, 500); // breve pausa prima del prossimo round
      } else {
        document.getElementById("status").textContent = `Sbagliato! Riprova lo stesso round...`;
      }
    }

    // Funzione per mostrare i risultati finali
    function showResults() {
      const mean1 = calculateMean(reactionTimes1);
      const mean2 = calculateMean(reactionTimes2);
      const variance1 = calculateVariance(reactionTimes1, mean1);
      const variance2 = calculateVariance(reactionTimes2, mean2);
      const stdDev1 = calculateStandardDeviation(variance1);
      const stdDev2 = calculateStandardDeviation(variance2);

      const resultText = `
        <strong>Risultati Finali</strong><br>
        Totale round: ${totalRounds}<br>
        Tempi di reazione ciclo 1 (ms): ${reactionTimes1.map(t => t.toFixed(2)).join(', ')}<br>
        Media ciclo 1: ${mean1.toFixed(2)} ms<br>
        Deviazione standard ciclo 1: ${stdDev1.toFixed(2)} ms<br><br>
        Tempi di reazione ciclo 2 (ms): ${reactionTimes2.map(t => t.toFixed(2)).join(', ')}<br>
        Media ciclo 2: ${mean2.toFixed(2)} ms<br>
        Deviazione standard ciclo 2: ${stdDev2.toFixed(2)} ms
      `;
      document.getElementById("result").innerHTML = resultText;
      document.getElementById("status").textContent = "Test completato!";
      document.getElementById("correct-color").textContent = "";

      // Avvia il reset del gioco dopo 1 minuto
      setTimeout(() => {
        resetGame();
      }, 60000); // Dopo 1 minuto il gioco si resetta

      // Crea il grafico con i dati delle reazioni
      createChart(mean1, mean2);
    }

    // Funzione per creare il grafico dei tempi di reazione
    function createChart(mean1, mean2) {
      const ctx = document.getElementById('reaction-chart').getContext('2d');
      const chart = new Chart(ctx, {
        type: 'scatter', // Grafico a dispersione per punti
        data: {
          labels: Array.from({ length: totalRounds }, (_, i) => `Round ${i + 1}`),
          datasets: [
            {
              label: 'Tempi di Reazione Ciclo 1 (ms)',
              data: reactionTimes1.map((t, i) => ({ x: i + 1, y: t.toFixed(2) })),
              borderColor: 'blue',
              backgroundColor: 'blue',
              pointRadius: 5,
              showLine: false,
            },
            {
              label: 'Tempi di Reazione Ciclo 2 (ms)',
              data: reactionTimes2.map((t, i) => ({ x: i + 1, y: t.toFixed(2) })),
              borderColor: 'purple',
              backgroundColor: 'purple',
              pointRadius: 5,
              showLine: false,
            },
            {
              label: 'Media Ciclo 1',
              data: Array(totalRounds).fill({ x: 1, y: mean1 }), // Linea orizzontale della media ciclo 1
              borderColor: 'red',
              backgroundColor: 'red',
              fill: false,
              borderWidth: 2,
              tension: 0,
              showLine: true,
            },
            {
              label: 'Media Ciclo 2',
              data: Array(totalRounds).fill({ x: 1, y: mean2 }), // Linea orizzontale della media ciclo 2
              borderColor: 'orange',
              backgroundColor: 'orange',
              fill: false,
              borderWidth: 2,
              tension: 0,
              showLine: true,
            }
          ]
        },
        options: {
          responsive: true,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Tempo (ms)'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Round'
              },
              ticks: {
                stepSize: 1
              }
            }
          }
        }
      });
    }

    // Funzione per resettare il gioco
    function resetGame() {
      currentRound = 0;
      cycle = 1;
      reactionTimes1 = [];
      reactionTimes2 = [];
      document.getElementById("result").innerHTML = "";
      startRound();  // Riapre il ciclo 1
    }

    // Avvia il test
    window.onload = () => startRound();
  </script>
</body>
</html>
